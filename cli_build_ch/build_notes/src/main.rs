// <----------------- Accepting Command Line Arguments ----------------->

// First task is to make minigrep accept two arguments: 1. the file path and
// 2. the string to search for

// We'd like to be able to run our program as shown below:

// ---------------------------
// $ cargo run -- searchstring example-filename.txt
// ---------------------------

// The program generated by 'cargo new' does not process arguments out of the
// box, there are crates you can find for that, but for now we'll implement
// the capability ourselves

// <----------------- Reading Argument Values ----------------->

// For our program to read CL args we needs the 'std::env::args'*** function
// This function returns an iterator of the CL args passed to the fn

// ***NOTE: std::env::args will panic if any argument contains invalid Unicode

// Iterators are next chapter, but for now: iterators produce a series of values
// and we can call the 'collect' method on an iterator to turn it into a collection
// (such as a vector) that contains all the elements the iterator produces

// Output so far:

// ---------------------------
// cargo run -- needle haystack
//     Finished dev [unoptimized + debuginfo] target(s) in 0.02s
//      Running `target/debug/minigrep needle haystack`
// [src/main.rs:5] args = [
//     "target/debug/minigrep", <--FIRST VALUE of vector is name of our binary
//     "needle",
//     "haystack",
// ]
// ---------------------------

// <----------- Saving the Argument Values in Variables ----------->
// We will simply assign references to the values in each of the vector locations
// query at index 1 (binary name is at 0), file path at index 2

// <----------- Reading a File ----------->
// To peform this function, we'll use another part of the standard library:
// the 'fs' crate (same naming convention as node)
// 'fs::read_to_string' opens a file at a specified path and returns a std::io::Result<String>
// containing the file's contents

// <----------- Refactoring to Improve Modularity and Errors ----------->

// <----------- Separation of Concerns for Binary Projects
// Rust community has developed guidelines for how to do this when the
// 'main' file starts getting too large in a project:
//  - Split project into main.rs and lib.rs files and move program logic into lib.rs
//  - As long as command line parsing logic remains small, it can remain in main.rs
//  - When command line logic gets complicated, extract it from main.rs to lib.rs

// Responsibilities that remain with main.rs file include:
// - Calling command line parsing logic with arg values
// - Setting up any other configuration
// - Calling a 'run' function in lib.rs
// - Handling the error if 'run' returns an error

// ^ Since main.rs cannot be tested directly, moving logic out into lib.rs lets you test it while
// main.rs logic can be verified by correctness by reading it


// <-------------------- Fixing the Error Handling -------------------->
//  1. added a arg check to the function and threw a panic if too few,
//  2. removed questionable use of panic and replaced with proper Result<Ok, Err> in build fn

// use std::process;
// fn main() {
//      let args: Vec<String> = env::args().collect();
//
//      let config = Config::build(&args).unwrap_or_else(|err| { <--UNWRAP OR ELSE method here allows
//                                                     // use to define our own custom error handling
//                                                     // uses closure to invoke an anon fn
//          println!("Problem parsing arguments: {err}"); <--SPECIFIES error using return ERR value from build
//          process::exit(1); <-- STOPS program immediately and returns number passed as an error status code
// });
// --snip--